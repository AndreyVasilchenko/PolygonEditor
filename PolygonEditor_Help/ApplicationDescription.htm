<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html><head>




  <meta name="GENERATOR" content="Microsoft® HTML Help Workshop 4.1"><title>ApplicationDescription</title></head><body style="margin: 12px; background-color: rgb(255, 255, 255); font-family: 'Trebuchet MS',Tahoma,Arial,Helvetica,sans-serif;">
<h2 style="color: rgb(61, 122, 153);"><span class="f_H1">Описание
приложения</span></h2>

&nbsp;&nbsp;&nbsp; <span class="f_H1">Основная тема тестового задания
- разбиение полигонов, предварительно созданных в программе при помощи
мыши или клавиатуры. Так как это задание предполагает активное
использование графических средств, то мной было принято решение для
исполнения задания использовать подсистему Windows
Presentation Foundation (WPF)
в
составе .NET Framework, использующую
языки C# и XAML.<br>
&nbsp;&nbsp;&nbsp; Название приложения появилось на первом этапе его
создания, когда поэтапно решались задачи по построению
</span><span class="f_H1">интерактивного </span><span class="f_H1">полигона. Эти этапы оставлены в приложении в виде отдельных задач:
1.Построение интерактивной точки; 2.Построение интерактивной линии;
3.Построение интерактивной полилинии; 4.Построение интерактивного
полигона.&nbsp; Получился своеобразный редактор для построения
различных по
степени сложности фигур. <br>
&nbsp;&nbsp;&nbsp; Если возникнет необходимость, то список фигур
обрабатывамых приложением
можно будет расширить фигурами любой произвольной геометрии и
сложности.
Расширяемость обеспечивается созданной моделью представления параметров
фигуры и форматом хранения этих параметров. В качестве формата хранения
параметров фигуры выбран формат сохранения структурированых данных -
Json.<br>
&nbsp;&nbsp;&nbsp; Формат данных оказал существенное влияние на выбор
СУБД для их
хранения. MongoDB - документориентированная </span><span class="f_H1">NoSQL
</span><span class="f_H1">СУБД, была выбрана
для этой цели, так как позволяет удобно хранить данные любой
структурной сложности и размера. MongoDB - серверная СУБД, поэтому в
приложениии реализован доступ к удаленной демонстрационной Базе Данных,
расположенной на VPS.<br>
&nbsp;&nbsp;&nbsp; Так как при написании приложения использовалась
система WPF,то этот выбор обусловил, при кодировании интерфейса пользователя,&nbsp;
примененение паттерна программирования MVVM(Model-View-ViewModel) в тех
местах, где это было целесообразно.<br>
&nbsp;&nbsp;&nbsp; При оформлении кнопочного интерфейса были
ипользованы </span><span class="f_H1">иконки, </span><span class="f_H1">переработанные из стандартных иконок или собственного дизайна.<br>
<br>
&nbsp;&nbsp;&nbsp; При решении основной задачи - Разбиение Полигонов -
чтобы "не изобретать велосипед", была изучена история решений этой
задачи. Цепочка решений, которую мне удалось проследить, получилась примерно
такая:<br>
&nbsp;&nbsp;&nbsp; - Алгоритм Вейлера-Азертона(Уайлера-Атертона)(1977г) - только для многоугольников, неимеюших самопересечений.<br>
&nbsp;&nbsp;&nbsp; - Алгоритм Ватти(1992г) - решает все варианты
булевых операций(с любыми видами полигонов), но очень громоздкий(более
5000строк кода на С++).<br>
</span><span class="f_H1">&nbsp;&nbsp;&nbsp; - Алгоритм
Гриннера-Хормана(1998) - проще и элегантнее, чем алгоритм Ватти, но не
обрабатывает многоугольники с вырождениями.</span><br>
<span class="f_H1">&nbsp;&nbsp;&nbsp; - Алгоритм Мартинеса-Руэды 1-я вариант(2008г) - работает быстрее, чем алгоритмы Ватти и Гриннера-Хормана</span><span class="f_H1"> и работает со всеми видами полигонов.</span><br>
<span class="f_H1">&nbsp;&nbsp;&nbsp; - Алгоритм Мартинеса-Руэды 2-й вариант(2013г) - более быстрый, чем 1-й вариант.<br>
</span><br>
<span class="f_H1">&nbsp;&nbsp;&nbsp; </span><span class="f_H1">Мне не
удалось
найти формальное описание алгоритма, который является </span><span class="f_H1">последним
пунктом в истории решений задачи - на данный момент это коммерческая
информация. Но попался в
свободном доступе на GitHub демонстрационный код, реализующий данный
алгоритм на языке node-JS(~2000 строк кода). Чтобы разобраться с
алгоритмом и использовать последнее и самое лучшее решение изучаемой
задачи, я решил
перевести этот код с node-JS на С# и реализовать этот блок программы в
виде
dll-библиотеки, что и было </span><span class="f_H1">мной </span><span class="f_H1"> сделано. Таким образом, была выполнена
основная задача: приложение получило возможность выполнять булевые
операции с полигонами и их коллекциями любой конфигурации как c выпуклыми, так и нет, как без самопересеченй, так и с ними.
Единственное ограничение демо-версии алгоритма - не обрабатываются
полигоны с отверстиями: вместо отверстий создаются отдельные полигоны.<br>
</span><span class="f_H1"><br>
</span>&nbsp; Прежде чем приступить к работе с программой
PolygonEditor, ознакомьтесь с разделом Справки: <a href="InterfaceSpecificity.htm" style="text-decoration: none; color: rgb(0, 175, 100);">"Особенности
Интерфейса"</a>.<br>

<br>

<br>

</body></html>